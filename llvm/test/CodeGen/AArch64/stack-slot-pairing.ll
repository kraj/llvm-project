; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=aarch64-linux-gnu -verify-machineinstrs < %s | FileCheck %s

; Test that demonstrates opportunity for stack slot reorganization to enable
; more load/store pairs. This function has many values that need to be spilled
; and reloaded, creating patterns where adjacent spills/reloads could become
; load/store pairs if their stack slots were adjacent.

define void @test_stack_slot_pairing(ptr %out, i64 %n) {
; CHECK-LABEL: test_stack_slot_pairing:
; CHECK:       // %bb.0: // %entry
; CHECK:         sub sp, sp, #192
; Multiple callee-saved register pairs should be saved
; CHECK-DAG:     stp x{{[0-9]+}}, x{{[0-9]+}}, [sp, {{.*}}] // 16-byte Folded Spill
; CHECK-DAG:     stp x{{[0-9]+}}, x{{[0-9]+}}, [sp, {{.*}}] // 16-byte Folded Spill
; CHECK-DAG:     stp x{{[0-9]+}}, x{{[0-9]+}}, [sp, {{.*}}] // 16-byte Folded Spill
; CHECK-DAG:     stp x{{[0-9]+}}, x{{[0-9]+}}, [sp, {{.*}}] // 16-byte Folded Spill
; CHECK-DAG:     stp x{{[0-9]+}}, x{{[0-9]+}}, [sp, {{.*}}] // 16-byte Folded Spill
; CHECK-DAG:     stp x{{[0-9]+}}, x{{[0-9]+}}, [sp, {{.*}}] // 16-byte Folded Spill
; Load pairs from the input
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [x0{{.*}}]
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [x0{{.*}}]
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [x0{{.*}}]
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [x0{{.*}}]
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [x0{{.*}}]
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [x0{{.*}}]
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [x0{{.*}}]
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [x0{{.*}}]
; Spills should use pairs
; CHECK-DAG:     stp x{{[0-9]+}}, x{{[0-9]+}}, [sp{{.*}}] // 16-byte Folded Spill
; CHECK-DAG:     stp x{{[0-9]+}}, x{{[0-9]+}}, [sp{{.*}}] // 16-byte Folded Spill
; CHECK-DAG:     stp x{{[0-9]+}}, x{{[0-9]+}}, [sp{{.*}}] // 16-byte Folded Spill
; CHECK-DAG:     stp x{{[0-9]+}}, x{{[0-9]+}}, [sp{{.*}}] // 16-byte Folded Spill
; CHECK:         //APP
; CHECK:         //NO_APP
; Reloads should use pairs
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [sp{{.*}}] // 16-byte Folded Reload
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [sp{{.*}}] // 16-byte Folded Reload
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [sp{{.*}}] // 16-byte Folded Reload
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [sp{{.*}}] // 16-byte Folded Reload
; Callee-saved register pairs should be restored
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [sp{{.*}}] // 16-byte Folded Reload
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [sp{{.*}}] // 16-byte Folded Reload
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [sp{{.*}}] // 16-byte Folded Reload
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [sp{{.*}}] // 16-byte Folded Reload
; CHECK-DAG:     ldp x{{[0-9]+}}, x{{[0-9]+}}, [sp{{.*}}] // 16-byte Folded Reload
; CHECK:         add sp, sp, #192
; CHECK:         ret
entry:
  ; Force many live values that will need to be spilled
  %v0 = load i64, ptr %out, align 8
  %p1 = getelementptr i64, ptr %out, i64 1
  %v1 = load i64, ptr %p1, align 8
  %p2 = getelementptr i64, ptr %out, i64 2
  %v2 = load i64, ptr %p2, align 8
  %p3 = getelementptr i64, ptr %out, i64 3
  %v3 = load i64, ptr %p3, align 8
  %p4 = getelementptr i64, ptr %out, i64 4
  %v4 = load i64, ptr %p4, align 8
  %p5 = getelementptr i64, ptr %out, i64 5
  %v5 = load i64, ptr %p5, align 8
  %p6 = getelementptr i64, ptr %out, i64 6
  %v6 = load i64, ptr %p6, align 8
  %p7 = getelementptr i64, ptr %out, i64 7
  %v7 = load i64, ptr %p7, align 8
  %p8 = getelementptr i64, ptr %out, i64 8
  %v8 = load i64, ptr %p8, align 8
  %p9 = getelementptr i64, ptr %out, i64 9
  %v9 = load i64, ptr %p9, align 8
  %p10 = getelementptr i64, ptr %out, i64 10
  %v10 = load i64, ptr %p10, align 8
  %p11 = getelementptr i64, ptr %out, i64 11
  %v11 = load i64, ptr %p11, align 8
  %p12 = getelementptr i64, ptr %out, i64 12
  %v12 = load i64, ptr %p12, align 8
  %p13 = getelementptr i64, ptr %out, i64 13
  %v13 = load i64, ptr %p13, align 8
  %p14 = getelementptr i64, ptr %out, i64 14
  %v14 = load i64, ptr %p14, align 8
  %p15 = getelementptr i64, ptr %out, i64 15
  %v15 = load i64, ptr %p15, align 8

  ; Create register pressure that forces spills
  ; Use inline asm to consume all registers
  call void asm sideeffect "", "~{x2},~{x3},~{x4},~{x5},~{x6},~{x7},~{x8},~{x9},~{x10},~{x11},~{x12},~{x13},~{x14},~{x15},~{x16},~{x17},~{x18},~{x19},~{x20},~{x21},~{x22},~{x23},~{x24},~{x25},~{x26},~{x27},~{x28}"()

  ; Now we need to reload the values - they should have been spilled
  ; Pairs that are stored/loaded together should ideally get adjacent stack slots

  ; First pair of values used together
  %sum01 = add i64 %v0, %v1
  store i64 %sum01, ptr %out, align 8

  ; Second pair of values used together
  %sum23 = add i64 %v2, %v3
  store i64 %sum23, ptr %p1, align 8

  ; Third pair of values used together
  %sum45 = add i64 %v4, %v5
  store i64 %sum45, ptr %p2, align 8

  ; Fourth pair of values used together
  %sum67 = add i64 %v6, %v7
  store i64 %sum67, ptr %p3, align 8

  ; Fifth pair of values used together
  %sum89 = add i64 %v8, %v9
  store i64 %sum89, ptr %p4, align 8

  ; Sixth pair of values used together
  %sum1011 = add i64 %v10, %v11
  store i64 %sum1011, ptr %p5, align 8

  ; Seventh pair of values used together
  %sum1213 = add i64 %v12, %v13
  store i64 %sum1213, ptr %p6, align 8

  ; Eighth pair of values used together
  %sum1415 = add i64 %v14, %v15
  store i64 %sum1415, ptr %p7, align 8

  ret void
}

; Test with floating point values
define void @test_fp_stack_slot_pairing(ptr %out) {
; CHECK-LABEL: test_fp_stack_slot_pairing:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #96
; CHECK-NEXT:    stp d15, d14, [sp, #32] // 16-byte Folded Spill
; CHECK-NEXT:    stp d13, d12, [sp, #48] // 16-byte Folded Spill
; CHECK-NEXT:    stp d11, d10, [sp, #64] // 16-byte Folded Spill
; CHECK-NEXT:    stp d9, d8, [sp, #80] // 16-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    .cfi_offset b8, -8
; CHECK-NEXT:    .cfi_offset b9, -16
; CHECK-NEXT:    .cfi_offset b10, -24
; CHECK-NEXT:    .cfi_offset b11, -32
; CHECK-NEXT:    .cfi_offset b12, -40
; CHECK-NEXT:    .cfi_offset b13, -48
; CHECK-NEXT:    .cfi_offset b14, -56
; CHECK-NEXT:    .cfi_offset b15, -64
; CHECK-NEXT:    ldp d0, d1, [x0]
; CHECK-NEXT:    ldp d2, d3, [x0, #16]
; CHECK-NEXT:    ldp d4, d5, [x0, #32]
; CHECK-NEXT:    fadd d6, d0, d1
; CHECK-NEXT:    ldp d0, d1, [x0, #48]
; CHECK-NEXT:    fadd d2, d2, d3
; CHECK-NEXT:    fadd d0, d0, d1
; CHECK-NEXT:    stp d2, d6, [sp] // 16-byte Folded Spill
; CHECK-NEXT:    fadd d2, d4, d5
; CHECK-NEXT:    stp d0, d2, [sp, #16] // 16-byte Folded Spill
; CHECK-NEXT:    //APP
; CHECK-NEXT:    //NO_APP
; CHECK-NEXT:    ldr d0, [sp, #8] // 8-byte Folded Reload
; CHECK-NEXT:    ldp d9, d8, [sp, #80] // 16-byte Folded Reload
; CHECK-NEXT:    ldp d11, d10, [sp, #64] // 16-byte Folded Reload
; CHECK-NEXT:    str d0, [x0]
; CHECK-NEXT:    ldr d0, [sp] // 8-byte Folded Reload
; CHECK-NEXT:    ldp d13, d12, [sp, #48] // 16-byte Folded Reload
; CHECK-NEXT:    str d0, [x0, #8]
; CHECK-NEXT:    ldr d0, [sp, #24] // 8-byte Folded Reload
; CHECK-NEXT:    ldp d15, d14, [sp, #32] // 16-byte Folded Reload
; CHECK-NEXT:    str d0, [x0, #16]
; CHECK-NEXT:    ldr d0, [sp, #16] // 8-byte Folded Reload
; CHECK-NEXT:    str d0, [x0, #24]
; CHECK-NEXT:    add sp, sp, #96
; CHECK-NEXT:    ret
entry:
  ; Load many FP values
  %v0 = load double, ptr %out, align 8
  %p1 = getelementptr double, ptr %out, i64 1
  %v1 = load double, ptr %p1, align 8
  %p2 = getelementptr double, ptr %out, i64 2
  %v2 = load double, ptr %p2, align 8
  %p3 = getelementptr double, ptr %out, i64 3
  %v3 = load double, ptr %p3, align 8
  %p4 = getelementptr double, ptr %out, i64 4
  %v4 = load double, ptr %p4, align 8
  %p5 = getelementptr double, ptr %out, i64 5
  %v5 = load double, ptr %p5, align 8
  %p6 = getelementptr double, ptr %out, i64 6
  %v6 = load double, ptr %p6, align 8
  %p7 = getelementptr double, ptr %out, i64 7
  %v7 = load double, ptr %p7, align 8

  ; Force spills by clobbering FP registers
  call void asm sideeffect "", "~{d0},~{d1},~{d2},~{d3},~{d4},~{d5},~{d6},~{d7},~{d8},~{d9},~{d10},~{d11},~{d12},~{d13},~{d14},~{d15},~{d16},~{d17},~{d18},~{d19},~{d20},~{d21},~{d22},~{d23},~{d24},~{d25},~{d26},~{d27},~{d28},~{d29},~{d30},~{d31}"()

  ; Use pairs of values together
  %sum01 = fadd double %v0, %v1
  store double %sum01, ptr %out, align 8

  %sum23 = fadd double %v2, %v3
  store double %sum23, ptr %p1, align 8

  %sum45 = fadd double %v4, %v5
  store double %sum45, ptr %p2, align 8

  %sum67 = fadd double %v6, %v7
  store double %sum67, ptr %p3, align 8

  ret void
}
