; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=loongarch32 %s -o - | FileCheck %s --check-prefix=LA32
; RUN: llc -mtriple=loongarch64 %s -o - | FileCheck %s --check-prefix=LA64

declare i32 @many_args_callee(i32 %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5, i32 %6, i32 %7, i32 %8, i32 %9)

define i32 @many_args_tail(i32 %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5, i32 %6, i32 %7, i32 %8, i32 %9) {
; LA32-LABEL: many_args_tail:
; LA32:       # %bb.0:
; LA32-NEXT:    ori $a0, $zero, 9
; LA32-NEXT:    st.w $a0, $sp, 4
; LA32-NEXT:    ori $a0, $zero, 8
; LA32-NEXT:    ori $a1, $zero, 1
; LA32-NEXT:    ori $a2, $zero, 2
; LA32-NEXT:    ori $a3, $zero, 3
; LA32-NEXT:    ori $a4, $zero, 4
; LA32-NEXT:    ori $a5, $zero, 5
; LA32-NEXT:    ori $a6, $zero, 6
; LA32-NEXT:    ori $a7, $zero, 7
; LA32-NEXT:    st.w $a0, $sp, 0
; LA32-NEXT:    move $a0, $zero
; LA32-NEXT:    b many_args_callee
;
; LA64-LABEL: many_args_tail:
; LA64:       # %bb.0:
; LA64-NEXT:    ori $a0, $zero, 9
; LA64-NEXT:    st.d $a0, $sp, 8
; LA64-NEXT:    ori $a0, $zero, 8
; LA64-NEXT:    ori $a1, $zero, 1
; LA64-NEXT:    ori $a2, $zero, 2
; LA64-NEXT:    ori $a3, $zero, 3
; LA64-NEXT:    ori $a4, $zero, 4
; LA64-NEXT:    ori $a5, $zero, 5
; LA64-NEXT:    ori $a6, $zero, 6
; LA64-NEXT:    ori $a7, $zero, 7
; LA64-NEXT:    st.d $a0, $sp, 0
; LA64-NEXT:    move $a0, $zero
; LA64-NEXT:    pcaddu18i $t8, %call36(many_args_callee)
; LA64-NEXT:    jr $t8
  %ret = tail call i32 @many_args_callee(i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9)
  ret i32 %ret
}

define i32 @many_args_musttail(i32 %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5, i32 %6, i32 %7, i32 %8, i32 %9) {
; LA32-LABEL: many_args_musttail:
; LA32:       # %bb.0:
; LA32-NEXT:    ori $a0, $zero, 9
; LA32-NEXT:    st.w $a0, $sp, 4
; LA32-NEXT:    ori $a0, $zero, 8
; LA32-NEXT:    ori $a1, $zero, 1
; LA32-NEXT:    ori $a2, $zero, 2
; LA32-NEXT:    ori $a3, $zero, 3
; LA32-NEXT:    ori $a4, $zero, 4
; LA32-NEXT:    ori $a5, $zero, 5
; LA32-NEXT:    ori $a6, $zero, 6
; LA32-NEXT:    ori $a7, $zero, 7
; LA32-NEXT:    st.w $a0, $sp, 0
; LA32-NEXT:    move $a0, $zero
; LA32-NEXT:    b many_args_callee
;
; LA64-LABEL: many_args_musttail:
; LA64:       # %bb.0:
; LA64-NEXT:    ori $a0, $zero, 9
; LA64-NEXT:    st.d $a0, $sp, 8
; LA64-NEXT:    ori $a0, $zero, 8
; LA64-NEXT:    ori $a1, $zero, 1
; LA64-NEXT:    ori $a2, $zero, 2
; LA64-NEXT:    ori $a3, $zero, 3
; LA64-NEXT:    ori $a4, $zero, 4
; LA64-NEXT:    ori $a5, $zero, 5
; LA64-NEXT:    ori $a6, $zero, 6
; LA64-NEXT:    ori $a7, $zero, 7
; LA64-NEXT:    st.d $a0, $sp, 0
; LA64-NEXT:    move $a0, $zero
; LA64-NEXT:    pcaddu18i $t8, %call36(many_args_callee)
; LA64-NEXT:    jr $t8
  %ret = musttail call i32 @many_args_callee(i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9)
  ret i32 %ret
}

; This function has more arguments than it's tail-callee. This isn't valid for
; the musttail attribute, but can still be tail-called as a non-guaranteed
; optimisation, because the outgoing arguments to @many_args_callee fit in the
; stack space allocated by the caller of @more_args_tail.
define i32 @more_args_tail(i32 %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5, i32 %6, i32 %7, i32 %8, i32 %9) {
; LA32-LABEL: more_args_tail:
; LA32:       # %bb.0:
; LA32-NEXT:    ori $a0, $zero, 9
; LA32-NEXT:    st.w $a0, $sp, 4
; LA32-NEXT:    ori $a0, $zero, 8
; LA32-NEXT:    ori $a1, $zero, 1
; LA32-NEXT:    ori $a2, $zero, 2
; LA32-NEXT:    ori $a3, $zero, 3
; LA32-NEXT:    ori $a4, $zero, 4
; LA32-NEXT:    ori $a5, $zero, 5
; LA32-NEXT:    ori $a6, $zero, 6
; LA32-NEXT:    ori $a7, $zero, 7
; LA32-NEXT:    st.w $a0, $sp, 0
; LA32-NEXT:    move $a0, $zero
; LA32-NEXT:    b many_args_callee
;
; LA64-LABEL: more_args_tail:
; LA64:       # %bb.0:
; LA64-NEXT:    ori $a0, $zero, 9
; LA64-NEXT:    st.d $a0, $sp, 8
; LA64-NEXT:    ori $a0, $zero, 8
; LA64-NEXT:    ori $a1, $zero, 1
; LA64-NEXT:    ori $a2, $zero, 2
; LA64-NEXT:    ori $a3, $zero, 3
; LA64-NEXT:    ori $a4, $zero, 4
; LA64-NEXT:    ori $a5, $zero, 5
; LA64-NEXT:    ori $a6, $zero, 6
; LA64-NEXT:    ori $a7, $zero, 7
; LA64-NEXT:    st.d $a0, $sp, 0
; LA64-NEXT:    move $a0, $zero
; LA64-NEXT:    pcaddu18i $t8, %call36(many_args_callee)
; LA64-NEXT:    jr $t8
  %ret = tail call i32 @many_args_callee(i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9)
  ret i32 %ret
}

; Again, this isn't valid for musttail, but can be tail-called in practice
; because the stack size if the same.
define i32 @different_args_tail_32bit(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4) {
; LA32-LABEL: different_args_tail_32bit:
; LA32:       # %bb.0:
; LA32-NEXT:    ori $a0, $zero, 9
; LA32-NEXT:    st.w $a0, $sp, 4
; LA32-NEXT:    ori $a0, $zero, 8
; LA32-NEXT:    ori $a1, $zero, 1
; LA32-NEXT:    ori $a2, $zero, 2
; LA32-NEXT:    ori $a3, $zero, 3
; LA32-NEXT:    ori $a4, $zero, 4
; LA32-NEXT:    ori $a5, $zero, 5
; LA32-NEXT:    ori $a6, $zero, 6
; LA32-NEXT:    ori $a7, $zero, 7
; LA32-NEXT:    st.w $a0, $sp, 0
; LA32-NEXT:    move $a0, $zero
; LA32-NEXT:    b many_args_callee
;
; LA64-LABEL: different_args_tail_32bit:
; LA64:       # %bb.0:
; LA64-NEXT:    addi.d $sp, $sp, -32
; LA64-NEXT:    .cfi_def_cfa_offset 32
; LA64-NEXT:    st.d $ra, $sp, 24 # 8-byte Folded Spill
; LA64-NEXT:    .cfi_offset 1, -8
; LA64-NEXT:    ori $a0, $zero, 9
; LA64-NEXT:    st.d $a0, $sp, 8
; LA64-NEXT:    ori $a0, $zero, 8
; LA64-NEXT:    ori $a1, $zero, 1
; LA64-NEXT:    ori $a2, $zero, 2
; LA64-NEXT:    ori $a3, $zero, 3
; LA64-NEXT:    ori $a4, $zero, 4
; LA64-NEXT:    ori $a5, $zero, 5
; LA64-NEXT:    ori $a6, $zero, 6
; LA64-NEXT:    ori $a7, $zero, 7
; LA64-NEXT:    st.d $a0, $sp, 0
; LA64-NEXT:    move $a0, $zero
; LA64-NEXT:    pcaddu18i $ra, %call36(many_args_callee)
; LA64-NEXT:    jirl $ra, $ra, 0
; LA64-NEXT:    ld.d $ra, $sp, 24 # 8-byte Folded Reload
; LA64-NEXT:    addi.d $sp, $sp, 32
; LA64-NEXT:    ret
  %ret = tail call i32 @many_args_callee(i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9)
  ret i32 %ret
}

define i32 @different_args_tail_64bit(i128 %0, i128 %1, i128 %2, i128 %3, i128 %4) {
; LA32-LABEL: different_args_tail_64bit:
; LA32:       # %bb.0:
; LA32-NEXT:    addi.w $sp, $sp, -16
; LA32-NEXT:    .cfi_def_cfa_offset 16
; LA32-NEXT:    st.w $ra, $sp, 12 # 4-byte Folded Spill
; LA32-NEXT:    .cfi_offset 1, -4
; LA32-NEXT:    ori $a0, $zero, 9
; LA32-NEXT:    st.w $a0, $sp, 4
; LA32-NEXT:    ori $a0, $zero, 8
; LA32-NEXT:    ori $a1, $zero, 1
; LA32-NEXT:    ori $a2, $zero, 2
; LA32-NEXT:    ori $a3, $zero, 3
; LA32-NEXT:    ori $a4, $zero, 4
; LA32-NEXT:    ori $a5, $zero, 5
; LA32-NEXT:    ori $a6, $zero, 6
; LA32-NEXT:    ori $a7, $zero, 7
; LA32-NEXT:    st.w $a0, $sp, 0
; LA32-NEXT:    move $a0, $zero
; LA32-NEXT:    bl many_args_callee
; LA32-NEXT:    ld.w $ra, $sp, 12 # 4-byte Folded Reload
; LA32-NEXT:    addi.w $sp, $sp, 16
; LA32-NEXT:    ret
;
; LA64-LABEL: different_args_tail_64bit:
; LA64:       # %bb.0:
; LA64-NEXT:    ori $a0, $zero, 9
; LA64-NEXT:    st.d $a0, $sp, 8
; LA64-NEXT:    ori $a0, $zero, 8
; LA64-NEXT:    ori $a1, $zero, 1
; LA64-NEXT:    ori $a2, $zero, 2
; LA64-NEXT:    ori $a3, $zero, 3
; LA64-NEXT:    ori $a4, $zero, 4
; LA64-NEXT:    ori $a5, $zero, 5
; LA64-NEXT:    ori $a6, $zero, 6
; LA64-NEXT:    ori $a7, $zero, 7
; LA64-NEXT:    st.d $a0, $sp, 0
; LA64-NEXT:    move $a0, $zero
; LA64-NEXT:    pcaddu18i $t8, %call36(many_args_callee)
; LA64-NEXT:    jr $t8
  %ret = tail call i32 @many_args_callee(i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9)
  ret i32 %ret
}

; Here, the caller requires less stack space for it's arguments than the
; callee, so it would not ba valid to do a tail-call.
define i32 @fewer_args_tail(i32 %0, i32 %1, i32 %2, i32 %3, i32 %4) {
; LA32-LABEL: fewer_args_tail:
; LA32:       # %bb.0:
; LA32-NEXT:    addi.w $sp, $sp, -16
; LA32-NEXT:    .cfi_def_cfa_offset 16
; LA32-NEXT:    st.w $ra, $sp, 12 # 4-byte Folded Spill
; LA32-NEXT:    .cfi_offset 1, -4
; LA32-NEXT:    ori $a0, $zero, 9
; LA32-NEXT:    st.w $a0, $sp, 4
; LA32-NEXT:    ori $a0, $zero, 8
; LA32-NEXT:    ori $a1, $zero, 1
; LA32-NEXT:    ori $a2, $zero, 2
; LA32-NEXT:    ori $a3, $zero, 3
; LA32-NEXT:    ori $a4, $zero, 4
; LA32-NEXT:    ori $a5, $zero, 5
; LA32-NEXT:    ori $a6, $zero, 6
; LA32-NEXT:    ori $a7, $zero, 7
; LA32-NEXT:    st.w $a0, $sp, 0
; LA32-NEXT:    move $a0, $zero
; LA32-NEXT:    bl many_args_callee
; LA32-NEXT:    ld.w $ra, $sp, 12 # 4-byte Folded Reload
; LA32-NEXT:    addi.w $sp, $sp, 16
; LA32-NEXT:    ret
;
; LA64-LABEL: fewer_args_tail:
; LA64:       # %bb.0:
; LA64-NEXT:    addi.d $sp, $sp, -32
; LA64-NEXT:    .cfi_def_cfa_offset 32
; LA64-NEXT:    st.d $ra, $sp, 24 # 8-byte Folded Spill
; LA64-NEXT:    .cfi_offset 1, -8
; LA64-NEXT:    ori $a0, $zero, 9
; LA64-NEXT:    st.d $a0, $sp, 8
; LA64-NEXT:    ori $a0, $zero, 8
; LA64-NEXT:    ori $a1, $zero, 1
; LA64-NEXT:    ori $a2, $zero, 2
; LA64-NEXT:    ori $a3, $zero, 3
; LA64-NEXT:    ori $a4, $zero, 4
; LA64-NEXT:    ori $a5, $zero, 5
; LA64-NEXT:    ori $a6, $zero, 6
; LA64-NEXT:    ori $a7, $zero, 7
; LA64-NEXT:    st.d $a0, $sp, 0
; LA64-NEXT:    move $a0, $zero
; LA64-NEXT:    pcaddu18i $ra, %call36(many_args_callee)
; LA64-NEXT:    jirl $ra, $ra, 0
; LA64-NEXT:    ld.d $ra, $sp, 24 # 8-byte Folded Reload
; LA64-NEXT:    addi.d $sp, $sp, 32
; LA64-NEXT:    ret
  %ret = tail call i32 @many_args_callee(i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9)
  ret i32 %ret
}

declare void @foo(i32, i32, i32, i32, i32, i32, i32, i32, i32)

define void @bar(i32 %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5, i32 %6, i32 %7, i32 %8) nounwind {
; LA32-LABEL: bar:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    addi.w $sp, $sp, -48
; LA32-NEXT:    st.w $ra, $sp, 44 # 4-byte Folded Spill
; LA32-NEXT:    st.w $fp, $sp, 40 # 4-byte Folded Spill
; LA32-NEXT:    st.w $s0, $sp, 36 # 4-byte Folded Spill
; LA32-NEXT:    st.w $s1, $sp, 32 # 4-byte Folded Spill
; LA32-NEXT:    st.w $s2, $sp, 28 # 4-byte Folded Spill
; LA32-NEXT:    st.w $s3, $sp, 24 # 4-byte Folded Spill
; LA32-NEXT:    st.w $s4, $sp, 20 # 4-byte Folded Spill
; LA32-NEXT:    st.w $s5, $sp, 16 # 4-byte Folded Spill
; LA32-NEXT:    st.w $s6, $sp, 12 # 4-byte Folded Spill
; LA32-NEXT:    move $fp, $a7
; LA32-NEXT:    move $s0, $a6
; LA32-NEXT:    move $s1, $a5
; LA32-NEXT:    move $s2, $a4
; LA32-NEXT:    move $s3, $a3
; LA32-NEXT:    move $s4, $a2
; LA32-NEXT:    move $s5, $a1
; LA32-NEXT:    move $s6, $a0
; LA32-NEXT:    ori $a0, $zero, 1
; LA32-NEXT:    st.w $a0, $sp, 0
; LA32-NEXT:    move $a0, $s6
; LA32-NEXT:    bl foo
; LA32-NEXT:    ori $a0, $zero, 2
; LA32-NEXT:    st.w $a0, $sp, 48
; LA32-NEXT:    move $a0, $s6
; LA32-NEXT:    move $a1, $s5
; LA32-NEXT:    move $a2, $s4
; LA32-NEXT:    move $a3, $s3
; LA32-NEXT:    move $a4, $s2
; LA32-NEXT:    move $a5, $s1
; LA32-NEXT:    move $a6, $s0
; LA32-NEXT:    move $a7, $fp
; LA32-NEXT:    ld.w $s6, $sp, 12 # 4-byte Folded Reload
; LA32-NEXT:    ld.w $s5, $sp, 16 # 4-byte Folded Reload
; LA32-NEXT:    ld.w $s4, $sp, 20 # 4-byte Folded Reload
; LA32-NEXT:    ld.w $s3, $sp, 24 # 4-byte Folded Reload
; LA32-NEXT:    ld.w $s2, $sp, 28 # 4-byte Folded Reload
; LA32-NEXT:    ld.w $s1, $sp, 32 # 4-byte Folded Reload
; LA32-NEXT:    ld.w $s0, $sp, 36 # 4-byte Folded Reload
; LA32-NEXT:    ld.w $fp, $sp, 40 # 4-byte Folded Reload
; LA32-NEXT:    ld.w $ra, $sp, 44 # 4-byte Folded Reload
; LA32-NEXT:    addi.w $sp, $sp, 48
; LA32-NEXT:    b foo
;
; LA64-LABEL: bar:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    addi.d $sp, $sp, -96
; LA64-NEXT:    st.d $ra, $sp, 88 # 8-byte Folded Spill
; LA64-NEXT:    st.d $fp, $sp, 80 # 8-byte Folded Spill
; LA64-NEXT:    st.d $s0, $sp, 72 # 8-byte Folded Spill
; LA64-NEXT:    st.d $s1, $sp, 64 # 8-byte Folded Spill
; LA64-NEXT:    st.d $s2, $sp, 56 # 8-byte Folded Spill
; LA64-NEXT:    st.d $s3, $sp, 48 # 8-byte Folded Spill
; LA64-NEXT:    st.d $s4, $sp, 40 # 8-byte Folded Spill
; LA64-NEXT:    st.d $s5, $sp, 32 # 8-byte Folded Spill
; LA64-NEXT:    st.d $s6, $sp, 24 # 8-byte Folded Spill
; LA64-NEXT:    move $fp, $a7
; LA64-NEXT:    move $s0, $a6
; LA64-NEXT:    move $s1, $a5
; LA64-NEXT:    move $s2, $a4
; LA64-NEXT:    move $s3, $a3
; LA64-NEXT:    move $s4, $a2
; LA64-NEXT:    move $s5, $a1
; LA64-NEXT:    move $s6, $a0
; LA64-NEXT:    ori $a0, $zero, 1
; LA64-NEXT:    st.d $a0, $sp, 0
; LA64-NEXT:    move $a0, $s6
; LA64-NEXT:    pcaddu18i $ra, %call36(foo)
; LA64-NEXT:    jirl $ra, $ra, 0
; LA64-NEXT:    ori $a0, $zero, 2
; LA64-NEXT:    st.d $a0, $sp, 96
; LA64-NEXT:    move $a0, $s6
; LA64-NEXT:    move $a1, $s5
; LA64-NEXT:    move $a2, $s4
; LA64-NEXT:    move $a3, $s3
; LA64-NEXT:    move $a4, $s2
; LA64-NEXT:    move $a5, $s1
; LA64-NEXT:    move $a6, $s0
; LA64-NEXT:    move $a7, $fp
; LA64-NEXT:    ld.d $s6, $sp, 24 # 8-byte Folded Reload
; LA64-NEXT:    ld.d $s5, $sp, 32 # 8-byte Folded Reload
; LA64-NEXT:    ld.d $s4, $sp, 40 # 8-byte Folded Reload
; LA64-NEXT:    ld.d $s3, $sp, 48 # 8-byte Folded Reload
; LA64-NEXT:    ld.d $s2, $sp, 56 # 8-byte Folded Reload
; LA64-NEXT:    ld.d $s1, $sp, 64 # 8-byte Folded Reload
; LA64-NEXT:    ld.d $s0, $sp, 72 # 8-byte Folded Reload
; LA64-NEXT:    ld.d $fp, $sp, 80 # 8-byte Folded Reload
; LA64-NEXT:    ld.d $ra, $sp, 88 # 8-byte Folded Reload
; LA64-NEXT:    addi.d $sp, $sp, 96
; LA64-NEXT:    pcaddu18i $t8, %call36(foo)
; LA64-NEXT:    jr $t8
entry:
  call void @foo(i32 %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5, i32 %6, i32 %7, i32 1)
  musttail call void @foo(i32 %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5, i32 %6, i32 %7, i32 2)
  ret void
}

declare void @sret_callee(ptr sret({ double, double }) align 8)

; Functions which return by sret can be tail-called because the incoming sret
; pointer gets passed through to the callee.
define void @sret_caller_tail(ptr sret({ double, double }) align 8 %result) {
; LA32-LABEL: sret_caller_tail:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    b sret_callee
;
; LA64-LABEL: sret_caller_tail:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    pcaddu18i $t8, %call36(sret_callee)
; LA64-NEXT:    jr $t8
entry:
  tail call void @sret_callee(ptr sret({ double, double }) align 8 %result)
  ret void
}

define void @sret_caller_musttail(ptr sret({ double, double }) align 8 %result) {
; LA32-LABEL: sret_caller_musttail:
; LA32:       # %bb.0: # %entry
; LA32-NEXT:    b sret_callee
;
; LA64-LABEL: sret_caller_musttail:
; LA64:       # %bb.0: # %entry
; LA64-NEXT:    pcaddu18i $t8, %call36(sret_callee)
; LA64-NEXT:    jr $t8
entry:
  musttail call void @sret_callee(ptr sret({ double, double }) align 8 %result)
  ret void
}
